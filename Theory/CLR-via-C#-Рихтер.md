# CLR via C#, Рихтер

## Глава 1. Устройство CLR. Модель выполнения кода.

### Manage Module

Код таких ЯП как C#, C++, F# компилируется в **IL** (Intermediate Language) **код**, после чего упаковывается в **управляемый модуль** (Manage Module, др. названия PE32 (x32) / PE32+ (x64)).
Manage Module (MM) состоит из:

* Заголовок PE32 / PE32+
* Заголовок CLR (прочая низкоуровневая информация о работе самого CLR)
* IL code
* Meta-данные (данные о данных)

### JIT

**JIT** (Just In Time) компиляция совершается в момент выполнения программы. Объясняю, когда мы собираем наш проект, то весь нами написанный код преобразуется в IL код. Когда в момент выполнения программы мы вызываем тот или иной метод, JIT компилятор компилирует уже готовый IL код в **byte-code**, то есть **машинный код** и помещает в участке памяти (ОЗУ) byte-code метода. При следующем обращении к уже скомпилированному в byte-code методу, JIT просто достает из памяти готовый byte-code, без повторной компиляции. Назревает разумный вопрос, - "А как у нас обрабатываются входные аргументы в методах?". Все просто. Их передают в byte-code и дело с концами. Также стоит отметить, что JIT компилирует только тот код, который будет выполняться. Ведь если посреди метода есть внезапный return, то скомпилирован метод будет только до return (экономия ресурсов).

### Meta-data

**Мета-данные** - это данные о данных. В CLR эта штука обязательна. Мета-данные позволяют использовать в проекте несколько dll файлов, тем самым связывая отдельные модули в группу. Так же мы можем использовать только определенные сборки библиотеки и не тащить за собой пласт ненужных классов и методов в финальную сборку. Но при необходимости, легко сможем подтянуть другие dll файлы в проект. 

### Ngen

Пару слов об этой утилите. **Ngen** является частью .NET и позволяет компилировать наш код в byte-code только один раз с последующим хранением в локальном хранилище. Как указано в [Википедии](https://ru.wikipedia.org/wiki/Ngen), это повышает производительность и эффективность программных решений.

### Домены приложения. Верифицируемость

**Домен приложения** (App Domain) - это выделенный участок памяти, который позволяет приложению использовать его, не беспокоясь о конфликтах доступа к памяти. То-есть возможность безопасного использования памяти приложением. IL язык является верифицируемым языком, что говорит о том, что среда выполнения CLR гарантирует безопасное использование памяти приложением. 

И тем самым получается, что IL - верифицируемый язык, а выделенный домен приложению обеспечивает безопасный доступ к памяти. Из-за такого "обложения безопасностью" в ходе исполнения приложения, может требоваться больше ресурсов на выделение того самого домена, а это (на доли сотой) не эффективно.

В языке C# есть особая конструкция **unsafe**, использование которой приводит к небезопасному задействованию участков памяти. Вы буквально шлете безопасность доступа к памяти CLR куда подальше и можете вытворять различный хаос.

Также, в теории, можно в один выделенный домен приложения уместить два, а то и более приложений и безопасно манипулировать памятью, но в практике такое еще не случалось (или случалось).  

### Дизассемблирование IL-кода

IL код грешит одной вещью, а именно хранением большого числа мета-данных. Из-за чего код, скомпилированный в среде CLR легко декомпилируется в удобочитаемый. Для препятствия этому процессу можно воспользоваться тремя способами:

* **Серверное приложение**. Организовать взаимодействие с функциями приложения через API или определенные протоколы
* **Обфускация**, то-есть запутываемость программного кода. Чтобы даже после декомпиляции приложения, человек не смог прочитать получившиеся исходные коды
* Использование небезопасного кода

### CTS и FCL

**CTS (Common Type System)** - это спецификация .NET, регламентирующая использование различных структур и типов в приложении. То-есть Int32 - целочисленный тип; Double - тип с плавающей запятой и тд. CTS является оберткой над FCL.

**FCL (Framework Class Library или BCL - Base Class Library)** - это набор базовых классов, методов, структур, доступный для использования на платформе .NET. Речь идет об использовании типов Int16, Int32, Double, Float, различных классов Console, List, Delegate и прочих других.

### Модификаторы доступа

* **private** - обращение доступно только в пределах класса
* **private protected** - доступно только наследникам класса класса только из данной сборки
* **internal** - доступно всем из данной сборки
* **protected internal** - доступно всем наследникам из данной и других сборок
* **public** - открыт для всех сборок

### CLS спецификация

**CLS (Common Language Specification)** - это общеязыковая спецификация. Средой выполнения CLR могут выполняться множество ЯП, они могут быть разными, однако у всех них есть общие правила (соглашения).

![](.\source\CLS.png)

Соглашение таково: Все используется через поля и исполняется методами. 

И есть такая особенность, как линейное наследование. То-есть можно наследоваться только от одного класса. В среде CLR это обязательное правило для всех языков которые <u>используются публично</u>. Некоторые особенности, которые доступны только внутри, могут применять и множественное наследование классов (вот здесь лучше почитать подробнее). 

## Глава 4. Основы типов

### Finalize метод

Данный метод вызывается у объекта прямо перед очисткой сборщиком мусора.

### Оператор new и создание объекта класса

Оператор **new** чаще всего используется для инициализации экземпляра класса, то-есть создании объекта. Для этого происходит выделение памяти под объект путем суммирования всех типов полей и свойств в самом классе (int = 32 бит, long = 64 бит, byte = 8 бит и тд). Также для создания объекта нужны вспомогательные поля, а именно **указатель на объект-тип** (адрес ячейки в памяти) и **блок синхронизации** (для работы с многопоточностью). Они на ряду с типами полей в классе занимают определенное место в управляемой куче (**heap**).

После выделения места под объект и занесения его в память, происходит инициализация полей стандартными значениями (0 или null). Только после чего идет заполнение полей значениями аргументов из конструктора.

```C#
internal class User {
	public User(string name){
		Name = name;
	}
	public int Age { get; set; }
	public string Name { get; }
}

internal void Main(string[] args){
    User user = new User(); // 0
    // 1. Выделение памяти
    // 2. Инициализация полей значениями по-умолчанию
    // 3. Переопределение полей значениями из конструктора
    // 4. Сохранение ссылки на объект в переменной user
}

```