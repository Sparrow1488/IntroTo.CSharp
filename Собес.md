**CLR, IL, CLS**

**CLR** ("Common Language Runtime", "общеязыковая исполняющая среда") - это компонент .NET Framework, основной задачей которого является управление интерпретацией и исполнением кода IL. CLR отвечает за изоляцию памяти приложений, проверку типов, безопасность кода, преобразование IL в машинный код.

**IL** (Intermediate Language) - код, содержащий набор инструкций, не зависящих от платформы. Иными словами, после компиляции исходного кода он преобразуется не в код для какой-то определенной платформы, а в промежуточный код на языке IL.

**CLS** ("Common Language Specification", общеязыковая спецификация) - это набор правил, следуя которым разработчики достигают бесконфликтной работы во всех языках .NET.

**В чем различие между Value Type и Reference Type?**

`Value Type` находятся в стеке, а `Reference Type` в куче.

**Что такое using, где используется и во что превращается после компиляции?**

Конструкция `using` - синтаксический сахар.

Применятся при 1) подключении пространств имен, 2) для обеспечения безопасной обработки объектов IDisposable - контроль ресурсов. 3) (C# 10) Добавление модификатора `global` к директиве `using` означает, что директива using должна применяться ко всем файлам в компиляции. Пример: `global using` 4) (C# 6) Директива `using static` указывает тип, доступ к статическим членам и вложенным типам которого можно получить, не указывая имя типа. Пример:

```C#
using static System.Console;
using static System.Math;
internal class Program {
	public static void Main() {
       WriteLine(Sqrt(3*3 + 4*4));
    }
 }
```

После компиляции превращается в конструкцию try { //code } finally { obj.Dispose() }

**Есть ли деструкторы в C#? Если есть, то что они из себя представляют?**

В C# есть есть как управляемые объекты, которые может запросто очистить сборщик мусора, так и неуправляемые, которые не могут контролироваться Garbage Collector, точнее он просто не знает как их очищать (обращение к API нашей ОС или работа с сетью). C# предоставляет 2 метода, позволяющих собственноручно указать, что нужно сделать, перед удалением экземпляра класса. И это: Dispose (от IDisposable) и Finalize. Через IDisposable - просто реализация интерфейса, а Finalize - определение деструктора в классе, который после компиляции преобразуется в метод Finalize от базового класса `object`.

Так выглядит деструктор класса `MyStream`:

```C#
// destructor
~MyStream(){
	// finalize action
}
```

После компиляции получится следующая конструкция:

```C#
protected override void Finalize(){
    try{
        // destructor code
    } finally{
        base.Finalize();
    }
}
```

И про метод Dispose. Компилируется конструкция using грубо говоря в такой код:

```C#
try{
    var stream = new MyStream();
    stream.WriteIntoFile("TEXT");
} finally{
	stream.Dispose();
}
```

Однако безопаснее Disposable объект вызывать в конструкции using, поскольку это гарантирует нам, что даже в случае исключения ресурсы будут высвобождены.

А лучше вообще комбинировать подходы. Но [правильно](https://metanit.com/sharp/tutorial/8.2.php).