## Кратко о главном

1. **Общение с hr**. Проверка базовых софт-скиллов, проверка коммуникативности и вежливости.
2. Возможно **тестовое задание**. Зависит от специфики компании и задач, которые в ней решают. В любом случае, по backend'у может быть задание на ASP, работу с БД или решение алгоритмических задач. Для последнего важно набить руку в решении задачек с LeetCode или CodeWars, а также почитать книги, по типу "Грокаем алгоритмы", также неплохо было бы узнать про оценку скорости алгоритма (О большое) и почитать больше статей на различных сайтах.
3. **Техническое собеседование**. На джуна задают вопросы на базовое знание .NET, CLR, IL, C# и тд. Все это я собрал и разобрал ниже. Опять таки, здесь главное погуглить "Собес C# <paste_level_your>" и повторить все, что изучал за годы обучения.

## Разбор части 3 - база языка, общие концепции

**CLR, IL, CLS**

**CLR** ("Common Language Runtime", "общеязыковая исполняющая среда") - это компонент .NET Framework, основной задачей которого является управление интерпретацией и исполнением кода IL. CLR отвечает за изоляцию памяти приложений, проверку типов, безопасность кода, преобразование IL в машинный код.

**IL** (Intermediate Language) - код, содержащий набор инструкций, не зависящих от платформы. Иными словами, после компиляции исходного кода он преобразуется не в код для какой-то определенной платформы, а в промежуточный код на языке IL.

**CLS** ("Common Language Specification", общеязыковая спецификация) - это набор правил, следуя которым разработчики достигают бесконфликтной работы во всех языках .NET.

#### В чем различие между Value Type и Reference Type?

`Value Type` находятся в стеке, а `Reference Type` в куче. Также бывают очень большие объекты и если размер одно из таких превышает 85000 байт, то он помещается в `Large Object Heap`

#### Что такое using, где используется и во что превращается после компиляции?

Конструкция `using` - синтаксический сахар.

Применятся при 1) подключении пространств имен, 2) для обеспечения безопасной обработки объектов IDisposable - контроль ресурсов. 3) (C# 10) Добавление модификатора `global` к директиве `using` означает, что директива using должна применяться ко всем файлам в компиляции. Пример: `global using` 4) (C# 6) Директива `using static` указывает тип, доступ к статическим членам и вложенным типам которого можно получить, не указывая имя типа. Пример:

```C#
using static System.Console;
using static System.Math;
internal class Program {
	public static void Main() {
       WriteLine(Sqrt(3*3 + 4*4));
    }
 }
```

После компиляции превращается в конструкцию try { //code } finally { obj.Dispose() }

#### Есть ли деструкторы в C#? Если есть, то что они из себя представляют?

В C# есть есть как управляемые объекты, которые может запросто очистить сборщик мусора, так и неуправляемые, которые не могут контролироваться Garbage Collector, точнее он просто не знает как их очищать (обращение к API нашей ОС или работа с сетью). C# предоставляет 2 метода, позволяющих собственноручно указать, что нужно сделать, перед удалением экземпляра класса. И это: Dispose (от IDisposable) и Finalize. Через IDisposable - просто реализация интерфейса, а Finalize - определение деструктора в классе, который после компиляции преобразуется в метод Finalize от базового класса `object`.

Так выглядит деструктор класса `MyStream`:

```C#
// destructor
~MyStream(){
	// finalize action
}
```

После компиляции получится следующая конструкция:

```C#
protected override void Finalize(){
    try{
        // destructor code
    } finally{
        base.Finalize();
    }
}
```

И про метод Dispose. Компилируется конструкция using грубо говоря в такой код:

```C#
try{
    var stream = new MyStream();
    stream.WriteIntoFile("TEXT");
} finally{
	stream.Dispose();
}
```

Однако безопаснее Disposable объект вызывать в конструкции using, поскольку это гарантирует нам, что даже в случае исключения ресурсы будут высвобождены.

А лучше вообще комбинировать подходы. Но [правильно](https://metanit.com/sharp/tutorial/8.2.php).

**Что такое Garbage Collector (сборщик мусора)?**

GC - инструмент CLR. Высвобождает из памяти объекты - удаляет из стека:

* ссылки на объекты reference type
* value type объекты

Сборщик мусора не запускается сразу после удаления из стека ссылки на объект, размещенный в куче. Он запускается в то время, когда среда CLR обнаружит в этом потребность, например, когда программе требуется дополнительная память.

Всего разделяют 3 поколения объектов:

* 0-е - новые объекты, которые еще ни разу не подвергались сборке мусора
* 1-е - объекты, которые пережили одну сборку
* 2-е - объекты, прошедшие более одной сборки мусора

#### Что такое ООП? Какие есть парадигмы. Кратко о каждой

Кста, ООП нафантазировал у себя в голове Алан Кей. Ну так, чиста для справки.

*Объект* - базовая единица объектно ориентированной системы.
*Посылка сообщений* - единственный способ обмена информацией между обектами.
Каждый объект принажлежит определенному классу.
*Поведение* объекта определяется его классом. 
Классы наследуют функциональность от предка.

1. **Инкапсуляция** - обеспечивает сокрытие, но не является им.
    Инкапсуляция (encapsulation) - это механизм, который объединяет данные и код, манипулирующий зтими данными, а также защищает и то, и другое от внешнего вмешательства или неправильного использования. Можно представить инкапсуляцию как защитную оболочку, которая предохраняет код и данные от произвольного доступа из других кодов, определённых вне этой оболочки. Характерной является ситуация, когда открытая часть объекта используется для того, чтобы обеспечить контролируемый интерфейс закрытых элементов объекта.

2. **Наследование** - это механизм языка, который позволяет описывать новый класс на основе существующего

   Сама по себе парадигма, ну так себе, так как дает возможность создать вереницу из сотни наследников от базового класса, внесение изменений в который может увинчаться пинком под зад от коллег по цеху. На такой случай не забываем про модификатор `sealed`. Но вообще, данная парадигма существует, по большому счету, ради полиморфизма.

3. **Полиморфизм** - это способность обьекта использовать методы производного класса.
Полиморфизм обеспечивает инкапсуляцию и имеет 3 формы:
* **Ad-Hoc** - возможность перегрузки методов.

```C#
public void WriteMessage(){
	Console.WriteLine("Paste your text");
}
public void WriteMessage(string text){
	Console.WriteLine(text);
}
```

* **Параметрический** - классы Generic.

* **Полиморфизм подтипов** - механизм наследования (переопределяем виртуальный метод) и апкаст (B : A; A field = new B()).

```C#
public virtual void WriteMessage(string text){ // класс A
	Console.WriteLine(text);
}
public override void WriteMessage(string text){ // класс-наследник B
	Logger.Log(text);
	base.WriteMessage(text);
}

public void Main(){
	A a = new A();
	A b = new B(); // upcast
	a.WriteMessage("Я хочу пиццу"); // тупа в консоль
	b.WriteMessage("Я хочу коллу"); // тупа в консоль и в лог-файл
}
```

Полиморфизм также обеспечивает сокрытие
```#C
public class B : A {
	public void Test2() => Console.Log("Test2");
}
public void Main(){
	A a = new A(); // типа в нем метод Test
	A b = new B();
	a.Test(); // Test
	b.Test2(); // после апкаста нет возможности скомпилить
}
```

4. **Абстракция** - задача заключается в том, чтобы выделить минимальные методы и поля класса для возможности решения задачи.

5. **Отправка сообщений** - способ сообщения между объектами. По факту, использование методов одного объекта другим.

```C#
// ко-ко-ко, мы так тактично выделели такую реализацию в целую парадигму, ко-ко-ко
public void Call(){ // класс One
	Logger.Log("Message");
} 
...
private One _one;
public void Foo(){ // класс Caller
	one.Call();
}
```

#### Что из себя представляют ключевые слова ref и out?

**ref** - ключевое слово, которое можно использовать для передачи ссылки на объект не только ссылочного типа, но и значимого.

**out** - ключевое слово, схожее по смыслу с ref. Передает ссылку на объект. При использовании в качестве возвращаемого значения в аргументе, нужно проинициализировать базовым значением.

#### Ну как там с паттернами?

Всего 3 категории базовых паттернов.

* **Порождающие** - беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей (фабричный метод, абстрактная фабрика, строитель, прототип, одиночка и др.)
* **Структурные** - показывают различные способы построения связей между объектами (адаптер, прокси, декоратор и др.)
* **Поведенческие** - заботятся об эффективной коммуникации между объектами (команда, итератор, снимок - Memento, наблюдатель, состояние и др.)

**Архитектурные паттерны приложений**: MVC, MVVM

*Вытекающие вопросы*: рассказать про MVC и MVVM



## Разбор части 3 - специфика направления - ASP.NET Core





